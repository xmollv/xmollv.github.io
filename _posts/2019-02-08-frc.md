---
layout: post
title:  "NSFetchedResultsController: There's a better way"
permalink: /frc
tags: [core-data]
---
In this post I wanted to share the way that I've been using `NSFetchedResultsController` in my Swift projects. The basic idea behind this approach is to wrap the `NSFetchedResultsController` and `NSFetchedResultsControllerDelegate` in a class that removes most of the boilerplate associated with it and makes it generic, so you can use it with any subclass of `NSManagedObject`.

```swift
protocol CoreDataNotifierDelegate: class {
    func willChangeContent()
    func didChangeSection(_ change: CoreDataNotifierSectionChange)
    func didChangeObject(_ change: CoreDataNotifierObjectChange)
    func didChangeContent()
    func startNotifyingFailed(with: Error)
}

enum CoreDataNotifierSectionChange {
    case insert(sectionIndex: Int)
    case delete(sectionIndex: Int)
}

enum CoreDataNotifierObjectChange {
    case update(indexPath: IndexPath)
    case insert(indexPath: IndexPath)
    case delete(indexPath: IndexPath)
    case move(from: IndexPath, to: IndexPath)
}

class CoreDataNotifier<T: NSManagedObject>: NSObject, NSFetchedResultsControllerDelegate {
    
    //MARK:- Private properties
    private let fetchResultController: NSFetchedResultsController<T>
    
    //MARK: Public properties
    weak var delegate: CoreDataNotifierDelegate? = nil
    
    //MARK:- Lifecycle
    init(fetchResultController: NSFetchedResultsController<T>) {
        self.fetchResultController = fetchResultController
        super.init()
    }
    
    //MARK:- Public methods
    func startNotifying() {
        self.fetchResultController.delegate = self
        do {
            try self.fetchResultController.performFetch()
        } catch {
            self.delegate?.startNotifyingFailed(with: error)
        }
    }
    
    func stopNotifying() {
        self.fetchResultController.delegate = nil
    }
    
    func element(at indexPath: IndexPath) -> T {
        return self.fetchResultController.object(at: indexPath)
    }
    
    func numberOfSections() -> Int {
        guard let numberOfSections = self.fetchResultController.sections?.count else { return 0 }
        return numberOfSections
    }
    
    func numberOfElements(inSection section: Int) -> Int {
        let numberOfSections = self.fetchResultController.sections?.count ?? 0
        guard section < numberOfSections else { return 0 }
        guard let section = self.fetchResultController.sections?[section] else { return 0 }
        return section.objects?.count ?? 0
    }
    
    //MARK:- NSFetchedResultsControllerDelegate
    func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        self.delegate?.willChangeContent()
    }
    
    func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange sectionInfo: NSFetchedResultsSectionInfo, atSectionIndex sectionIndex: Int, for type: NSFetchedResultsChangeType) {
        switch type {
        case .insert:
            self.delegate?.didChangeSection(.insert(sectionIndex: sectionIndex))
        case .delete:
            self.delegate?.didChangeSection(.delete(sectionIndex: sectionIndex))
        default:
            assertionFailure("This should never happen based on the docs")
        }
    }
    
    func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {
        let change: CoreDataNotifierObjectChange
        switch type {
        case .update:
            guard let indexPath = indexPath else {
                assertionFailure()
                return
            }
            change = .update(indexPath: indexPath)
        case .insert:
            guard let newIndexPath = newIndexPath else {
                assertionFailure()
                return
            }
            change = .insert(indexPath: newIndexPath)
        case .move:
            guard let indexPath = indexPath, let newIndexPath = newIndexPath else {
                assertionFailure()
                return
            }
            change = .move(from: indexPath, to: newIndexPath)
        case .delete:
            guard let indexPath = indexPath else {
                assertionFailure()
                return
            }
            change = .delete(indexPath: indexPath)
        }
        self.delegate?.didChangeObject(change)
    }
    
    func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        self.delegate?.didChangeContent()
    }
}
```

Now let's write a basic `UIViewController` that uses the `CoreDataNotifier` to drive it's data. It's out of the scope of this post to show [how to create](https://github.com/xmollv/Llitgi/blob/c61be8c6bcfb3f7a5fcba4c90cfde462d8c699b9/llitgi/DataProvider/CoreData/CoreDataFactory.swift#L46) an `NSFetchedResultsController`, but as you can see on the `init(fetchResultController:)`, you need one in order to instantiate this class. Make sure to replace the type used in the `CoreDataNotifier<NSManagedObject>` to the type that makes sense in your project.

```swift
final class ListViewController: UITableViewController {
    
    let notifier: CoreDataNotifier<NSManagedObject>
    
    init(notifier: CoreDataNotifier<NSManagedObject>) {
        self.notifier = notifier
        super.init(style: .plain)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.notifier.delegate = self
        self.notifier.startNotifying()
    }
}

extension ListViewController: CoreDataNotifierDelegate {
    func willChangeContent() {
        self.tableView.beginUpdates()
    }
    
    func didChangeSection(_ change: CoreDataNotifierSectionChange) {
        switch change {
        case .insert(let sectionIndex):
            self.tableView.insertSections(IndexSet(integer: sectionIndex), with: .automatic)
        case .delete(let sectionIndex):
            self.tableView.deleteSections(IndexSet(integer: sectionIndex), with: .automatic)
        }
    }
    
    func didChangeObject(_ change: CoreDataNotifierObjectChange) {
        switch change {
        case .update(let indexPath):
            self.tableView.reloadRows(at: [indexPath], with: .automatic)
        case .insert(let indexPath):
            self.tableView.insertRows(at: [indexPath], with: .automatic)
        case .delete(let indexPath):
            self.tableView.deleteRows(at: [indexPath], with: .automatic)
        case .move(let from, let to):
            self.tableView.deleteRows(at: [from], with: .automatic)
            self.tableView.insertRows(at: [to], with: .automatic)
        }
    }
    
    func didChangeContent() {
        self.tableView.endUpdates()
    }
    
    func startNotifyingFailed(with error: Error) {
        assertionFailure(error.localizedDescription)
        self.notifier.startNotifying()
    }
}
```

If we wan't to go one step further, we could refactor the conformance of `CoreDataNotifierDelegate` into a protocol with a default implementation like this:

```swift
protocol TableViewControllerNotifier: CoreDataNotifierDelegate where Self: UITableViewController {
    associatedtype T: NSManagedObject
    var notifier: CoreDataNotifier<T> { get }
}

extension TableViewControllerNotifier {
    func willChangeContent() {
        self.tableView.beginUpdates()
    }

    func didChangeSection(_ change: CoreDataNotifierSectionChange) {
        switch change {
        case .insert(let sectionIndex):
            self.tableView.insertSections(IndexSet(integer: sectionIndex), with: .automatic)
        case .delete(let sectionIndex):
            self.tableView.deleteSections(IndexSet(integer: sectionIndex), with: .automatic)
        }
    }

    func didChangeObject(_ change: CoreDataNotifierObjectChange) {
        switch change {
        case .update(let indexPath):
            self.tableView.reloadRows(at: [indexPath], with: .automatic)
        case .insert(let indexPath):
            self.tableView.insertRows(at: [indexPath], with: .automatic)
        case .delete(let indexPath):
            self.tableView.deleteRows(at: [indexPath], with: .automatic)
        case .move(let from, let to):
            self.tableView.deleteRows(at: [from], with: .automatic)
            self.tableView.insertRows(at: [to], with: .automatic)
        }
    }

    func didChangeContent() {
        self.tableView.endUpdates()
    }

    func startNotifyingFailed(with error: Error) {
        assertionFailure(error.localizedDescription)
        self.notifier.startNotifying()
    }
}
```

After creaing the above protocol with the default implementation, we can refactor our `ListViewController` to make it look like this:

```swift
final class ListViewController: UITableViewController, TableViewControllerNotifier {

    let notifier: CoreDataNotifier<NSManagedObject>

    init(notifier: CoreDataNotifier<NSManagedObject>) {
        self.notifier = notifier
        super.init(style: .plain)
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        self.notifier.delegate = self
        self.notifier.startNotifying()
    }
}
```

Following this approach, we've created a class that handles all the boilerplate associated with using an `NSFetchedResultsController`. We could have stoped there and used it as is, but adding the `TableViewControllerNotifier` with the default implementation makes the code even more clear, and nothing stops you from adding your own implementation to any of the `CoreDataNotifierDelegate` methods if you need more customization.

If you want to see the usage of the `CoreDataNotifier` on a real project, every `UITableViewController` on [Llitgi](https://itunes.apple.com/app/id1355340767) uses this approach. The code is available on [GitHub](https://github.com/xmollv/Llitgi).