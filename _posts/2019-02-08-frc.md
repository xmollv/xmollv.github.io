---
layout: post
title:  "NSFetchedResultsController: A better way"
permalink: /frc
tags: [core-data]
---
I think that almost everyones agrees that `NSFetchedResultsController` is the best way to display the data that's handled by `CoreData` on the UI. The solution presented on this post is tailored for using it in conjuction with a `UITableViewController`, but adapting it to a `UICollectionViewController` should be fairly easy.

Let's create a new class that will act as a wrapper around `NSFetchedResultsController` to make our life easier. At the end of the post you'll be able to download the entire class, but for now let's go step by step. On this new class, let's add the following the protocols:

```swift
enum CoreDataNotifierSectionChange {
    case insert(sectionIndex: Int)
    case delete(sectionIndex: Int)
}

enum CoreDataNotifierObjectChange {
    case update(indexPath: IndexPath)
    case insert(indexPath: IndexPath)
    case delete(indexPath: IndexPath)
    case move(from: IndexPath, to: IndexPath)
}
```

Now that we have declared the different changes that an `NSFetchedResultsController` can produce, let's add a new protocol that the delegate of the `CoreDataNotifier` will have to implement. With this, we'll forward the method calls from the `NSFetchedResultsController` to the delegate that implements it on a more swifty way:

```swift
protocol CoreDataNotifierDelegate: class {
    func willChangeContent()
    func didChangeSection(_ change: CoreDataNotifierSectionChange)
    func didChangeObject(_ change: CoreDataNotifierObjectChange)
    func didChangeContent()
    func startNotifyingFailed(with: Error)
}
```

The `CoreDataNotifier` should look like this:

```swift
class CoreDataNotifier<T: NSManagedObject>: NSObject, NSFetchedResultsControllerDelegate {
    
    //MARK:- Private properties
    private let fetchResultController: NSFetchedResultsController<T>
    
    //MARK: Public properties
    weak var delegate: CoreDataNotifierDelegate? = nil
    
    //MARK:- Lifecycle
    init(fetchResultController: NSFetchedResultsController<T>) {
        self.fetchResultController = fetchResultController
        super.init()
    }
    
    //MARK:- Public methods
    func startNotifying() {
        self.fetchResultController.delegate = self
        do {
            try self.fetchResultController.performFetch()
        } catch {
            self.delegate?.startNotifyingFailed(with: error)
        }
    }
    
    func stopNotifying() {
        self.fetchResultController.delegate = nil
    }
    
    func element(at indexPath: IndexPath) -> T {
        return self.fetchResultController.object(at: indexPath)
    }
    
    func numberOfSections() -> Int {
        guard let numberOfSections = self.fetchResultController.sections?.count else { return 0 }
        return numberOfSections
    }
    
    func numberOfElements(inSection section: Int) -> Int {
        let numberOfSections = self.fetchResultController.sections?.count ?? 0
        guard section < numberOfSections else { return 0 }
        guard let section = self.fetchResultController.sections?[section] else { return 0 }
        return section.objects?.count ?? 0
    }
    
    //MARK:- NSFetchedResultsControllerDelegate
    func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        self.delegate?.willChangeContent()
    }
    
    func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange sectionInfo: NSFetchedResultsSectionInfo, atSectionIndex sectionIndex: Int, for type: NSFetchedResultsChangeType) {
        switch type {
        case .insert:
            self.delegate?.didChangeSection(.insert(sectionIndex: sectionIndex))
        case .delete:
            self.delegate?.didChangeSection(.delete(sectionIndex: sectionIndex))
        default:
            assertionFailure("This should never happen based on the docs")
        }
    }
    
    func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {
        let change: CoreDataNotifierObjectChange
        
        switch type {
        case .update:
            guard let indexPath = indexPath else {
                assertionFailure()
                return
            }
            change = .update(indexPath: indexPath)
        case .insert:
            guard let newIndexPath = newIndexPath else {
                assertionFailure()
                return
            }
            change = .insert(indexPath: newIndexPath)
        case .move:
            guard let indexPath = indexPath, let newIndexPath = newIndexPath else {
                assertionFailure()
                return
            }
            change = .move(from: indexPath, to: newIndexPath)
        case .delete:
            guard let indexPath = indexPath else {
                assertionFailure()
                return
            }
            change = .delete(indexPath: indexPath)
        }
        
        self.delegate?.didChangeObject(change)
    }
    
    func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        self.delegate?.didChangeContent()
    }
}
```

Let's go step by step over the class defined above:
- We declare it generic over `T` and constraint it to `NSManagedObject` to be able to use it with any object that inherits from `NSManagedObject`.
- We declare ourselves as the `NSFetchedResultsControllerDelegate` and to do so we must conform to `NSObject`.
- As you can see on the `init(fetchResultController:)`, to create this class we need to instantiate it with an `NSFetchedResultsController`.
- When we call the `startNotifying()` method, we tell to the `fetchResultController` stored in our class that we're also it's delegate.