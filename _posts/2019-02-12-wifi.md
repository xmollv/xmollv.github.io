---
layout: post
title:  "How to connect to a WiFi hotspot programmatically on iOS"
permalink: /wifi
---

Did you know that since iOS 11 you can connect to a WiFi network programmatically from your iOS app? It totally flew under my radar for some time, but I needed to do it for an app that I've been working on and it turns out that the code needed to accomplish this feature is pretty simple, but it has a few gotchas.

The first thing that you have to do is go to `Your Project` > `Capabilities` > `Hotspot Configuration` and enable it.

Let's assume that on our app we have a `UIViewController` that displays the possibility to join a WiFi network. Let's create a protocol with a default implementation to make our life easier:

```swift
import NetworkExtension
import SystemConfiguration.CaptiveNetwork

protocol WiFiJoinable {
    func join(ssid: String, completion: @escaping ((Error?) -> Void))
}

extension WiFiJoinable where Self: UIViewController {
    func join(ssid: String, completion: @escaping ((Error?) -> Void)) {
        
        let configuration = NEHotspotConfiguration(ssid: ssid)
        configuration.joinOnce = false
        
        NEHotspotConfigurationManager.shared.apply(configuration) { (error) in
            completion(error)
        }
    }
}
```

That's everything that you need in order to connect to a WiFi hotspot from your iOS apps, but there are a few things that you should be aware of:

- The error returned on the completion handler of `NEHotspotConfigurationManager.shared.apply(_:completionHandler)` doesn't conform to the `Error` protocol in Swift, which makes error handling more complicated than what it should be. [Open Radar](http://www.openradar.me/37604384)
- If you try to connect when you already configured the Hotspot, the completion handler will return `NEHotspotConfigurationError.alreadyAssociated` so be careful when handling that error case because you might not want to display any error to the user.

## Captive portal

If the WiFi network where your users will connect needs to display a Captive Portal, you need to do an extra step. In order to tell the system that you want the Captive Portal to show up in your application you need to add the [UIRequiresPersistentWiFi](https://developer.apple.com/documentation/bundleresources/information_property_list/uirequirespersistentwifi) key to your `Info.plist`:
```
<key>UIRequiresPersistentWiFi</key>
<true/>
```

Doing so, you're telling the system that you're a _WiFi Application_ and if the network needs it, the system can display the captive portal on top of your app.

## Current SSID

On iOS 11, you don't need any extra entitlement to read the SSID of the connected WiFi network, but since iOS 12 you need to enable a new capability in your app. To do so, you have to go to `Your Project` > `Capabilities` > `Access WiFi Information` and enable it.

Now we can extend the `WiFiJoinable` protocol that we created previously with a computed variable that returns the name of the SSID of the WiFi network that we're connected to:

```swift
protocol WiFiJoinable {
    var connectedSSID: String? { get }
    ...
}

extension WiFiJoinable where Self: UIViewController {
    var connectedSSID: String? {
        guard let interfaces = CNCopySupportedInterfaces() as NSArray? else { return nil }
        // https://bugs.swift.org/browse/SR-7015
        let ssids = interfaces.compactMap { interface in
            guard CFGetTypeID(interface as AnyObject) == CFStringGetTypeID() else { return nil }
            return (interface as! CFString)
        }.compactMap { CNCopyCurrentNetworkInfo($0) as NSDictionary? }
        .compactMap { $0[kCNNetworkInfoKeySSID as String] as? String }
        
        return ssids.first
    }
    ...
}
```

The code is not very pretty because interacting with `CFString` from Swift is still pretty messy, and the compiler doesn't help at all. With the code above, you're able to read the SSID name of the current WiFi.